# COLLECTION OF AIMS SPECIFIC SCRIPTS AND METHODS
# This assumes that a connection to a database with properly configured
# tables for thucs is available

from pathlib import Path

import copy
from multiprocessing.pool import ThreadPool
from functools import partial

import json

import pandas as pd
import geopandas as gpd

from sqlalchemy import create_engine, text as sql_text
from sqlalchemy import URL

from pyagnps import annagnps, utils

class AIMSWatershed:
    def __init__(self, path_to_json_creds, **kwargs):
        credentials = open_creds_dict(path_to_json_creds)
        url_object = create_db_url_object(credentials)

        self.engine = create_engine(url_object)
        self.path_to_json_creds = Path(path_to_json_creds)

        self.thuc_id        = kwargs.get("thuc_id", None)

        self.outlet_x       = kwargs.get("outlet_x", None) # In EPSG 4326
        self.outlet_y       = kwargs.get("outlet_y", None)

        self.start_time     = kwargs.get("start_time", None)
        self.end_time       = kwargs.get("end_time", None)

        self.watershed_name        = kwargs.get("watershed_name", "AIMS Watershed")
        self.watershed_description = kwargs.get("watershed_description", "Watershed generated by pyAGNPS and AIMS")
        self.watershed_location    = kwargs.get("watershed_location", "A Watershed in continental United States")

        self.climate_method = kwargs.get("climate_method", "nldas2_database")

        # Placeholder for static files
        self.nldas2_centroids = None
        self.scs_storm_types  = None
        self.precip_zones     = None

        self.output_folder = Path(kwargs.get("output_folder", "/tmp/"))
        self.export_gis    = kwargs.get("export_gis", True)
        self.MAXITER_CLIMATE_QUERY = kwargs.get("MAXITER_CLIMATE_QUERY", 10)

        # Geometries
        # self.cells_geometry = None

        # self.reaches_geometry = None

        # # Data Sections
        # self.df_cells = None
        # self.cells_list = []

        # self.df_reaches = None
        # self.reaches_list = []

        # self.df_soil_sata = None
        # self.soil_ids_list = []


    def set_metadata(self, **kwargs):
        """ Defines the metadata for the watershed. """

        self.outlet_x = kwargs.get("outlet_x", self.outlet_x)
        self.outlet_y = kwargs.get("outlet_y", self.outlet_y)

        self.start_time = kwargs.get("start_time", self.start_time)
        self.end_time   = kwargs.get("end_time", self.end_time)

        self.watershed_name        = kwargs.get("watershed_name", self.watershed_name)
        self.watershed_description = kwargs.get("watershed_description", self.watershed_description)
        self.watershed_location    = kwargs.get("watershed_location", self.watershed_location)

        self.output_folder = Path(kwargs.get("output_folder", self.output_folder))
        self.export_gis    = kwargs.get("export_gis", self.export_gis)
        self.MAXITER_CLIMATE_QUERY = kwargs.get("MAXITER_CLIMATE_QUERY", self.MAXITER_CLIMATE_QUERY)     


    def get_thuc_id_by_xy(self, x=None, y=None):
        """ Returns the thuc_id for which the coordinates belong to. """
        if x is None or y is None:
            x, y = self.outlet_x, self.outlet_y
        else:
            self.outlet_x, self.outlet_y = x, y

        sql = sql_text(
            f"SELECT thuc_near_run_id_tr({x},{y})"
        )
        thuc = pd.read_sql(sql, self.engine)
        thuc_id = thuc.iloc[0].values[0]

        self.thuc_id = thuc_id
        return thuc_id
    
    def get_outlet_xy_from_thuc_id_and_reach_id(self, thuc_id, reach_id=2):
        """ If not specified the reach_id defaults to 2, the most downstream reach.
        This function returns the x and y coordinates of centroid of the reach_id in thuc_id."""
        sql = sql_text(
            f"""SELECT ST_X(ST_Centroid(ST_Collect(ST_Transform(geom, 4326)))) AS lon, 
                ST_Y(ST_Centroid(ST_Collect(ST_Transform(geom, 4326)))) AS lat 
            FROM thuc_{thuc_id}_annagnps_reach_ids
            WHERE dn = {reach_id}
            """
        )
        df = pd.read_sql(sql, self.engine)

        x, y = df["lon"].to_list()[0], df["lat"].to_list()[0]

        self.outlet_x = x
        self.outlet_y = y

        return x, y
    
    def set_reaches_for_output(self, output_reaches=['OUTLET']):
        """ Set the output_reaches for the simulation. """
        if output_reaches:
            self.output_reaches = [reach for reach in output_reaches]

    def load_nldas2_centroids(self, path_to_nldas2_centroids=None):
        if path_to_nldas2_centroids is None:
            path_to_nldas2_centroids = "https://amazon.ncche.olemiss.edu:8443/Luc/pyagnps/-/raw/main/inputs/climate/NLDAS2_GRID_CENTROIDS_epsg4326.gpkg"
        else:
            path_to_nldas2_centroids = Path(path_to_nldas2_centroids)

        self.nldas2_centroids = gpd.read_file(path_to_nldas2_centroids)

    def load_scs_storm_types(self, path_to_scs_storm_types=None):
        if path_to_scs_storm_types is None:
            path_to_scs_storm_types = "https://amazon.ncche.olemiss.edu:8443/Luc/rusle2-climate-shapefile/-/raw/main/data/scs_storm_types.gpkg"
        else:
            path_to_scs_storm_types = Path(path_to_scs_storm_types)

        self.scs_storm_types = pd.read_file(path_to_scs_storm_types)

    def load_precip_zones(self, path_to_precip_zones=None):
        if path_to_precip_zones is None:
            path_to_precip_zones = "https://amazon.ncche.olemiss.edu:8443/Luc/rusle2-climate-shapefile/-/raw/main/outputs/precip_zones_RUSLE2_cleaned_manually_extrapolated_pchip_linear_US_units.gpkg"
        else:
            path_to_precip_zones = Path(path_to_precip_zones)

        self.precip_zones = gpd.read_file(path_to_precip_zones)

    def load_static_files(self, **kwargs):

        path_to_nldas2_centroids = kwargs.get("path_to_nldas2_centroids", None)
        path_to_scs_storm_types = kwargs.get("path_to_scs_storm_types", None)
        path_to_precip_zones = kwargs.get("path_to_precip_zones", None)

        self.load_nldas2_centroids(path_to_nldas2_centroids=path_to_nldas2_centroids)
        self.load_scs_storm_types(path_to_scs_storm_types=path_to_scs_storm_types)
        self.load_precip_zones(path_to_precip_zones=path_to_precip_zones)

    def make_watershed_output_dirs(self):

        subdirs = ['general', 'climate', 'simulation', 'watershed'].extend('GIS' if self.export_gis else [])
        
        folder_paths = annagnps.make_annagnps_inputs_dirs(self.output_folder, subdirs=subdirs)
        
        output_folders = {
            dir_name: path 
            for dir_name, path in zip(subdirs, folder_paths)
        }

        return output_folders
    
    def query_cells(self):

        if self.thuc_id is None:
            self.get_thuc_id_by_xy()
        
        thuc_id = self.thuc_id
        lon, lat = self.outlet_x, self.outlet_y

        # Geometry of cells
        cells_query = f"SELECT geom, cell_id FROM thuc_cell_geo_tr({lon},{lat}, '{thuc_id}')"

        cells_geometry = gpd.read_postgis(sql=sql_text(cells_query), con=self.engine.connect(), geom_col='geom')
        cells_geometry = cells_geometry.dissolve(by='cell_id')

        cells_list = cells_geometry['cell_id'].unique() # List of cell_ids
        
        # Cells data section
        cells_string = ", ".join(map(str, cells_list.tolist()))
        cells_data_section = f"SELECT * FROM thuc_{thuc_id}_annagnps_cell_data_section WHERE cell_id in ({cells_string})"

        df_cells = pd.read_sql_query(sql=sql_text(cells_data_section), con=self.engine.connect())

        cells_geometry = cells_geometry.merge(df_cells, on='cell_id')

        self.df_cells = df_cells

        self.cells_geometry = cells_geometry
        self.cells_list = cells_list

    def query_reaches(self):

        if self.thuc_id is None:
            self.get_thuc_id_by_xy()

        thuc_id = self.thuc_id
        lon, lat = self.outlet_x, self.outlet_y

        reaches_query = f"SELECT geom, reach_id FROM thuc_reach_geo_tr({lon},{lat}, '{thuc_id}')"

        reaches_geometry = gpd.read_postgis(sql=sql_text(reaches_query), con=self.engine.connect(), geom_col='geom')
        reaches_geometry = reaches_geometry.dissolve(by='reach_id')

        reaches_list = reaches_geometry['reach_id'].unique() # List of reach_ids
        reaches_string = ", ".join(map(str, reaches_list.tolist()))

        # Reaches data section
        reaches_data_section = f"SELECT * FROM thuc_{thuc_id}_annagnps_reach_data_section WHERE reach_id in ({reaches_string})"

        df_reaches = pd.read_sql_query(sql=sql_text(reaches_data_section), con=self.engine.connect())

        reaches_geometry = reaches_geometry.merge(df_reaches, on='reach_id')

        df_reaches_valid = annagnps.make_df_reaches_valid(df_reaches)

        self.df_reaches = df_reaches_valid

        self.reaches_geometry = reaches_geometry
        self.reaches_list = reaches_list
    
    def query_soil(self):

        soil_ids_list = self.df_cells['soil_id'].unique()
        soil_ids_string = ", ".join(map(str, soil_ids_list.tolist()))

        query_soil = f"""SELECT * FROM usa_valid_soil_data WHERE "Soil_ID" in ({soil_ids_string})"""
        query_soil_layers = f"""SELECT * FROM usa_valid_soil_layers_data WHERE "Soil_ID" in ({soil_ids_string})"""
        query_raw = f"""SELECT * FROM raw_nrcs_soil_data WHERE "mukey" in ({soil_ids_string})"""

        df_soil_data = pd.read_sql_query(sql=sql_text(query_soil), con=self.engine.connect())
        df_soil_layers_data = pd.read_sql_query(sql=sql_text(query_soil_layers), con=self.engine.connect())\
                            .sort_values(by=['Soil_ID','Layer_Number'])

        df_raw = pd.read_sql_query(sql=sql_text(query_raw), con=self.engine.connect())

        self.soil_ids_list = soil_ids_list
        self.df_soil_data = df_soil_data
        self.df_soil_layers_data = df_soil_layers_data
        self.df_raw = df_raw

    def query_management_field(self):

        mgmt_field_ids_list = self.df_cells['mgmt_field_id'].unique()
        mgmt_field_ids_string = ", ".join(f"'{m}'" for m in mgmt_field_ids_list)

        query_mgmt_field_data = f"""SELECT * FROM annagnps_mgmt_field WHERE "Field_ID" in ({mgmt_field_ids_string})"""
        df_mgmt_field = pd.read_sql_query(sql=sql_text(query_mgmt_field_data), con=self.engine.connect())

        self.df_mgmt_field = df_mgmt_field
        self.df_mgmt_field_ids_list = mgmt_field_ids_list

    def query_management_schedule(self):

        mgmt_schedule_ids_list = self.df_mgmt_field['Mgmt_Schd_ID'].unique()
        mgmt_schedule_ids_string = ", ".join(f"'{m}'" for m in mgmt_schedule_ids_list)

        query_mgmt_schd_data = f"""SELECT * FROM annagnps_mgmt_schd WHERE "Mgmt_Schd_ID" in ({mgmt_schedule_ids_string})"""
        df_mgmt_schd = pd.read_sql_query(sql=sql_text(query_mgmt_schd_data), con=self.engine.connect())

        self.df_mgmt_schd = df_mgmt_schd
        self.df_mgmt_schedule_ids_list = mgmt_schedule_ids_list

    def query_management_crop(self):

        mgmt_crop_ids_list = self.df_mgmt_schd['New_Crop_ID'].dropna().unique()
        mgmt_crop_ids_string = ", ".join(f"'{m}'" for m in mgmt_crop_ids_list)

        query_mgmt_schd_data = f"""SELECT * FROM annagnps_crop WHERE "Crop_ID" in ({mgmt_crop_ids_string})"""
        df_mgmt_crop = pd.read_sql_query(sql=sql_text(query_mgmt_schd_data), con=self.engine.connect())

        self.df_mgmt_crop = df_mgmt_crop
        self.df_mgmt_crop_ids_list = mgmt_crop_ids_list

    def query_management_crop_growth(self):

        mgmt_crop_ids_list = self.df_mgmt_schd['New_Crop_ID'].dropna().unique()
        mgmt_crop_ids_string = ", ".join(f"'{m}'" for m in mgmt_crop_ids_list)

        query_mgmt_crop_growth_data = f"""SELECT * FROM annagnps_crop_growth WHERE "Crop_Growth_ID" in ({mgmt_crop_ids_string})"""
        df_mgmt_crop_growth = pd.read_sql_query(sql=sql_text(query_mgmt_crop_growth_data), con=self.engine.connect())

        self.df_mgmt_crop_growth = df_mgmt_crop_growth
        self.mgmt_crop_ids_list = mgmt_crop_ids_list

    def query_management_non_crop(self):

        mgmt_non_crop_ids_list = self.df_mgmt_schd['New_Non-Crop_ID'].dropna().unique()
        mgmt_non_crop_ids_string = ", ".join(f"'{m}'" for m in mgmt_non_crop_ids_list)

        query_mgmt_non_cropdata = f"""SELECT * FROM annagnps_non_crop WHERE "Non-Crop_ID" in ({mgmt_non_crop_ids_string})"""
        df_mgmt_non_crop = pd.read_sql_query(sql=sql_text(query_mgmt_non_cropdata), con=self.engine.connect())

        self.df_mgmt_non_crop = df_mgmt_non_crop
        self.df_mgmt_non_crop_ids_list = mgmt_non_crop_ids_list

    def query_management_operation(self):

        mgmt_oper_ids_list = self.df_mgmt_schd['Mgmt_Operation_ID'].dropna().unique()
        mgmt_oper_ids_string = ", ".join(f"'{m}'" for m in mgmt_oper_ids_list)

        query_mgmt_oper_data = f"""SELECT * FROM annagnps_mgmt_oper WHERE "Mgmt_Operation_ID" in ({mgmt_oper_ids_string})"""

        df_mgmt_oper = pd.read_sql_query(sql=sql_text(query_mgmt_oper_data), con=self.engine.connect())

        self.df_mgmt_oper = df_mgmt_oper
        self.df_mgmt_oper_ids_list = mgmt_oper_ids_list

    def query_runoff_curve(self):

        roc_ids_list = self.df_mgmt_schd['Curve_Number_ID'].dropna().unique()
        roc_ids_string = ", ".join(f"'{m}'" for m in roc_ids_list)

        query_roc_data = f"""SELECT * FROM annagnps_runoff_curve WHERE "Curve_Number_ID" in ({roc_ids_string})"""
        df_roc = pd.read_sql_query(sql=sql_text(query_roc_data), con=self.engine.connect())

def open_creds_dict(path_to_json_creds):
    with open(path_to_json_creds, "r") as f:
        credentials = json.load(f)
        return credentials
    
def create_db_url_object(credentials):
    url_object = URL.create(
        "postgresql",
        username=credentials["user"],
        password=credentials["password"],
        host=credentials["host"],
        port=credentials["port"],
        database=credentials["database"],
    )
    return url_object